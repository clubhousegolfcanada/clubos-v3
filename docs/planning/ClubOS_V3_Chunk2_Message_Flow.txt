ClubOS V3 - Chunk 2: Message Flow, Thread State, and Escalation Logic

ğŸ“ Scope

Define how ClubOS V3 handles incoming customer messages, classifies intent, routes to actions, and escalates if required. Establish internal thread state tracking, escalation decision logic, and message queue management.

ğŸ”„ Cross-Referenced Corrections
Early Plan                    â†’ Final Decision
Static message parsing        â†’ Message flow is live-classified + context-aware
No thread states             â†’ Threads are assigned status with intent + state
Human-only escalation        â†’ AI escalates based on configured failure thresholds
No queue management          â†’ Priority queue with FIFO + emergency override

ğŸ“¦ Dependencies
* OperatorGPT must:
  â—‹ Receive message input
  â—‹ Access booking + system state (NinjaOne, DB)
  â—‹ Maintain message â†’ thread linkage
  â—‹ Manage message queue
* Escalation paths configured per category
* Optional: Slack fallback for human escalation

ğŸ”§ Tasks

[2.1] Message Flow Routing & Classification
* Incoming messages are processed in real time via priority queue
* Each message is classified by intent using:
  â—‹ Keyword matching (primary)
  â—‹ Category tags from SOPs
  â—‹ Semantic similarity (if confidence < threshold)
  â—‹ Context from booking/location data
* Classification output:
{
  "intent": "tech_issue",
  "sub_intent": "trackman_freeze",
  "confidence": 0.93,
  "matched_sop": "tech-013",
  "keywords_matched": ["frozen", "trackman", "stuck"]
}
* Matched to SOPs via vector search or tag
* Booking + bay context is attached

[2.2] Define Thread Status Enum (Enhanced)
Every customer thread stores a live status:
"pending" |              // Just received, not processed
"awaiting_ai" |         // Being processed by AI
"awaiting_response" |   // AI responded, waiting for customer
"ai_resolved" |         // AI successfully handled
"escalated" |           // Sent to human operator
"in_progress" |         // Human working on it
"resolved" |            // Human marked complete
"manual_override" |     // Operator took control
"timeout" |             // No resolution within time limit
"merged"                // Duplicate merged with another thread

LLM uses status + last action to decide next step.

[2.3] Message Queue Management
* Priority levels:
  â—‹ EMERGENCY (keywords: "fire", "injury", "emergency")
  â—‹ HIGH (active booking issues)
  â—‹ NORMAL (general inquiries)
  â—‹ LOW (feedback, suggestions)
* Queue behavior:
  â—‹ EMERGENCY jumps to front
  â—‹ Otherwise FIFO within priority level
  â—‹ Max queue size: 100 (configurable)
  â—‹ Overflow triggers operator alert

[2.4] Escalation Trigger Logic (Enhanced)
Escalation is triggered when:
* autonomy = false for category
* SOP fails (e.g. reset unsuccessful and no fallback allowed)
* Customer sentiment negative (detected patterns):
  â—‹ "still not working"
  â—‹ "this is ridiculous"
  â—‹ "I want a refund"
  â—‹ "let me speak to someone"
  â—‹ Multiple "?" or "!" in succession
* AI confidence falls below minimum threshold
* Time-based triggers:
  â—‹ No resolution within 15 minutes
  â—‹ Customer waiting > 5 minutes for response
  â—‹ Thread idle > 30 minutes

Escalation triggers:
* Slack alert (if enabled)
* Thread moves to "escalated"
* Operator gets inline summary of what was attempted
* AI stops processing thread

[2.5] AI Retry Behavior
Controlled via per-action config:
{
  "category": "tech",
  "max_fallbacks": 1,
  "retry_delay": 2,
  "await_customer_feedback": true,
  "timeout_minutes": 15
}
Retry logic always waits for:
* Booking data
* Customer reply
* System status confirmation
* Timeout expiration

[2.6] Thread Merge Logic
* Duplicate detection:
  â—‹ Same phone number + similar intent within 30 minutes
  â—‹ Same location/bay + overlapping time
* Merge behavior:
  â—‹ Newer thread marked as "merged"
  â—‹ Messages consolidated in primary thread
  â—‹ Customer notified: "I see you messaged about this earlier..."
  â—‹ All actions/logs linked to primary
* Manual merge option for operators

ğŸ¯ Expected Behavior
* Every customer message is routed through a thread with tracked status
* AI attempts 1-2 known resolutions (if allowed), then escalates
* Threads are not freeform chats â€“ they follow intent â†’ action â†’ feedback â†’ status
* Queue ensures high-priority issues handled first
* Duplicate messages are intelligently merged
* Time limits prevent threads from hanging indefinitely
* Operators can view thread state, actions taken, and escalation history

proceed to Chunk 3: Action Execution, System State, and Outcome Logging.